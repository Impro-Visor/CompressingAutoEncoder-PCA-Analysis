import numpy as np
import scipy as sp
from scipy import special
from matplotlib.mlab import PCA
import itertools

featureMatrix = np.loadtxt("featureMatrix.mat", delimiter=",")
referenceQueueMatrix = np.loadtxt("refQueueFeatureMatrix.mat", delimiter=",")
featureMatrix = sp.special.logit(featureMatrix)
referenceQueueMatrix = sp.special.logit(referenceQueueMatrix)
results = PCA(featureMatrix)
print(results.Wt)
print(len(results.Wt[:,0]))


pca_mean = results.mu #the mean vector
pca_components = results.Wt #matrix of the component vectors
pca_component_strengths = results.s #vector of the eigenvalues for each component

#the principal components (added to the eigenvalue for each feature) added to the mean
final_components = results.mu + (results.Wt * results.s[:,np.newaxis])
no_mean = results.Wt*results.s[:,np.newaxis]

start = 0

graph_data = results.Y[:,start:start+3]

#############################################

from mpl_toolkits.mplot3d import Axes3D
import matplotlib.pyplot as plt
import matplotlib.cm as cm

#Everything above this line was copied from the file queuePCA.py
#############################################

'''
	The purpose of this file is to generate and save files of matrices whose rows are linear combinations of existing feature vectors and principal component vectors.
	The resulting matrices are then fed through the second half of the autoencoder in lstmprovisor-java, which can be found on GitHub.
	We have had some success with the matrices generated by lin_comb() in that what it generated seemed vaguely melody-like.	
'''

def test_matrix(n=0, d=8):
	'''generates a matrix with d rows of a vector that is a copy of the nth component'''
	desiredVector = final_components[n]
	desiredMatrix = [desiredVector]*d
	np.savetxt('sample_matrix' + str(n) + '.mat',desiredMatrix, delimiter=',')

def lin_comb():
	'''The purpose of this function is to create matrices of linear combinations of existing feature vectors and principal component vectors'''
	#currently, it's set up such that it adds the first principal component to every feature vector
	old_feature_matrix = np.loadtxt('interp_feature_matrix', delimiter=',')
	principal_component0 = sp.special.expit(no_mean[0])
	principal_component1 = sp.special.expit(no_mean[1])
	new_feature_matrix = map(lambda x : x+principal_component0, old_feature_matrix)
	np.savetxt('linear_combination.mat', new_feature_matrix, delimiter=',')

def sigmoided_PCA():
	'''saves a file of the re-sigmoided PCA matrix'''
	output_matrix = sp.special.expit(final_components)
	np.savetxt('test.mat', output_matrix, delimiter=',')

lin_comb()